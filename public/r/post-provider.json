{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "post-provider",
  "type": "registry:lib",
  "title": "Lens Post Provider",
  "description": "A provider of a shared Lens post context for queries and operations.",
  "dependencies": [
    "@lens-protocol/react@0.0.0-canary-20250725092937",
    "@lens-protocol/client@0.0.0-canary-20250725092937",
    "@lens-protocol/metadata@2.1.0",
    "@lens-chain/storage-client@1.0.6",
    "@lens-chain/sdk@1.0.3",
    "wagmi@2.15.3"
  ],
  "files": [
    {
      "path": "registry/new-york/lib/lens-post-provider.tsx",
      "content": "import { createContext, ReactNode, useEffect, useState } from \"react\";\nimport {\n  AnyPost,\n  CreatePostRequest,\n  EvmAddress,\n  evmAddress,\n  PaymentSource,\n  Post,\n  postId as toPostId,\n  SessionClient,\n  TxHash,\n  useBookmarkPost,\n  usePost,\n  useUndoBookmarkPost,\n} from \"@lens-protocol/react\";\nimport { executePostAction, post as createPost, repost as createRepost } from \"@lens-protocol/client/actions\";\nimport { handleOperationWith } from \"@lens-protocol/client/viem\";\nimport { useReactionToggle } from \"@/registry/new-york/hooks/use-reaction-toggle\";\nimport { NATIVE_TOKEN } from \"@/registry/new-york/lib/lens-utils\";\nimport { textOnly } from \"@lens-protocol/metadata\";\nimport { immutable, StorageClient } from \"@lens-chain/storage-client\";\nimport { chains } from \"@lens-chain/sdk/viem\";\nimport { WalletClient } from \"viem\";\n\nexport type OptimisticState = {\n  liked: boolean;\n  commented: boolean;\n  collected: boolean;\n  repostedOrQuoted: boolean;\n  tipped: boolean;\n  bookmarked: boolean;\n};\n\nexport type Referral = {\n  percent: number;\n  address: EvmAddress;\n};\n\ntype PostContextType = {\n  post: AnyPost | undefined | null;\n  loading: boolean;\n  error?: Error;\n  optimistic: OptimisticState;\n  toggleLike: () => Promise<void>;\n  comment: (content: string) => Promise<TxHash | undefined>;\n  collect: (paymentSource?: PaymentSource, referrals?: Referral[]) => Promise<TxHash | undefined>;\n  repost: () => Promise<TxHash | undefined>;\n  quote: (content: string) => Promise<TxHash | undefined>;\n  tip: (paymentSource: PaymentSource, amount: string, tokenAddress: string) => Promise<TxHash | undefined>;\n  toggleBookmark: () => Promise<void>;\n};\n\nexport const LensPostContext = createContext<PostContextType | undefined>(undefined);\n\ntype Props = {\n  /**\n   * The Lens Session Client used for making authenticated calls\n   */\n  sessionClient: SessionClient | null | undefined;\n\n  /**\n   * The wallet client from viem used to sign messages for authentication.\n   */\n  walletClient?: WalletClient;\n\n  postId: string;\n\n  children: ReactNode;\n\n  useTestnet?: boolean;\n};\n\nexport const LensPostProvider = ({ sessionClient, walletClient, postId, children, useTestnet = false }: Props) => {\n  const { data, loading, error } = usePost({ post: postId });\n\n  const [post, setPost] = useState<Post | undefined | null>(data?.__typename === \"Repost\" ? data.repostOf : data);\n\n  const operations = post && \"operations\" in post ? post.operations : null;\n  const stats = post && \"stats\" in post ? post.stats : null;\n\n  const [optimistic, setOptimistic] = useState<OptimisticState>({\n    liked: operations?.hasUpvoted ?? false,\n    bookmarked: operations?.hasBookmarked ?? false,\n    collected: operations?.hasSimpleCollected ?? false,\n    tipped: operations?.hasTipped ?? false,\n    commented: operations?.hasCommented.optimistic ?? operations?.hasCommented.onChain ?? false,\n    repostedOrQuoted:\n      operations?.hasReposted.optimistic ??\n      operations?.hasReposted.onChain ??\n      operations?.hasQuoted.optimistic ??\n      operations?.hasQuoted.onChain ??\n      false,\n  });\n\n  useEffect(() => {\n    setPost(data?.__typename === \"Repost\" ? data.repostOf : data);\n  }, [data]);\n\n  const storageClient = StorageClient.create();\n  const { execute: toggleReaction } = useReactionToggle();\n  const { execute: bookmarkPost } = useBookmarkPost();\n  const { execute: undoBookmarkPost } = useUndoBookmarkPost();\n\n  const chain = useTestnet ? chains.testnet : chains.mainnet;\n\n  const switchChain = async () => {\n    await walletClient?.switchChain({ id: chain.id });\n  };\n\n  const toggleLike = async () => {\n    if (!post || !sessionClient?.isSessionClient()) return;\n\n    setOptimistic(optimistic => ({\n      ...optimistic,\n      liked: !optimistic?.liked,\n    }));\n\n    const res = await toggleReaction({ post, session: sessionClient });\n\n    if (res.isErr()) {\n      setOptimistic(optimistic => ({\n        ...optimistic,\n        liked: !optimistic?.liked,\n      }));\n      throw res.error;\n    }\n\n    setPost(prevPost => {\n      if (!prevPost) return null;\n      return {\n        ...prevPost,\n        stats: {\n          ...prevPost.stats,\n          upvotes: prevPost.stats.upvotes + (prevPost.operations?.hasUpvoted ? -1 : 1),\n        },\n        ...(prevPost.operations\n          ? {\n              operations: {\n                ...prevPost.operations,\n                hasUpvoted: !prevPost.operations?.hasUpvoted,\n              },\n            }\n          : {\n              operations: {\n                hasUpvoted: true,\n              },\n            }),\n      } as Post;\n    });\n  };\n\n  const comment = async (content: string): Promise<TxHash | undefined> => {\n    if (!post) {\n      throw new Error(\"Cannot comment without a post\");\n    }\n\n    if (!sessionClient?.isSessionClient() || !walletClient) {\n      throw new Error(\"Must be logged in to comment on a post\");\n    }\n\n    await switchChain();\n\n    const metadata = textOnly({ content });\n    const acl = immutable(chain.id);\n    const { uri } = await storageClient.uploadAsJson(metadata, { acl });\n    const postRequest: CreatePostRequest = {\n      contentUri: uri,\n      commentOn: {\n        post: post.id,\n      },\n    };\n\n    const previouslyCommented = optimistic.commented;\n\n    setOptimistic(optimistic => ({\n      ...optimistic,\n      commented: true,\n    }));\n\n    const postResponse = await createPost(sessionClient, postRequest)\n      .andThen(handleOperationWith(walletClient))\n      .andThen(sessionClient.waitForTransaction);\n\n    if (postResponse.isErr()) {\n      console.error(\"Error posting comment:\", postResponse.error);\n      setOptimistic(optimistic => ({\n        ...optimistic,\n        commented: previouslyCommented,\n      }));\n      throw postResponse.error;\n    }\n\n    return postResponse.value;\n  };\n\n  const collect = async (paymentSource?: PaymentSource, referrals?: Referral[]): Promise<TxHash | undefined> => {\n    if (!post) {\n      throw new Error(\"Cannot collect without a post\");\n    }\n\n    if (!sessionClient?.isSessionClient() || !walletClient) {\n      throw new Error(\"Must be logged in to collect a post\");\n    }\n\n    await switchChain();\n\n    setOptimistic(optimistic => ({\n      ...optimistic,\n      collected: true,\n    }));\n\n    const res = await executePostAction(sessionClient, {\n      post: post.id,\n      action: {\n        simpleCollect: {\n          selected: true,\n          paymentSource,\n          referrals,\n        },\n      },\n    })\n      .andThen(handleOperationWith(walletClient))\n      .andThen(sessionClient.waitForTransaction);\n\n    if (res.isErr()) {\n      console.error(\"Error collecting post:\", res.error);\n      setOptimistic(optimistic => ({\n        ...optimistic,\n        collected: false,\n      }));\n      throw res.error;\n    }\n\n    return res.value;\n  };\n\n  const repost = async (): Promise<TxHash | undefined> => {\n    if (!sessionClient?.isSessionClient() || !walletClient) {\n      throw new Error(\"Must be logged in to repost\");\n    }\n\n    await switchChain();\n\n    const previouslyReposted = optimistic.repostedOrQuoted;\n\n    setOptimistic(optimistic => ({\n      ...optimistic,\n      repostedOrQuoted: true,\n    }));\n\n    const res = await createRepost(sessionClient, {\n      post: toPostId(postId),\n    })\n      .andThen(handleOperationWith(walletClient))\n      .andThen(sessionClient.waitForTransaction);\n\n    if (res.isErr()) {\n      console.error(\"Error reposting post:\", res.error);\n      setOptimistic(optimistic => ({\n        ...optimistic,\n        repostedOrQuoted: previouslyReposted,\n      }));\n      throw res.error;\n    }\n\n    return res.value;\n  };\n\n  const quote = async (content: string): Promise<TxHash | undefined> => {\n    if (!post) {\n      throw new Error(\"Cannot quote without a post\");\n    }\n\n    if (!sessionClient?.isSessionClient() || !walletClient) {\n      throw new Error(\"Must be logged in to quote a post\");\n    }\n\n    await switchChain();\n\n    const metadata = textOnly({ content });\n    const acl = immutable(chain.id);\n    const { uri } = await storageClient.uploadAsJson(metadata, { acl });\n    const postRequest: CreatePostRequest = {\n      contentUri: uri,\n      quoteOf: {\n        post: post.id,\n      },\n    };\n\n    const previouslyQuoted = optimistic.repostedOrQuoted;\n\n    setOptimistic(optimistic => ({\n      ...optimistic,\n      repostedOrQuoted: true,\n    }));\n\n    const postResponse = await createPost(sessionClient, postRequest)\n      .andThen(handleOperationWith(walletClient))\n      .andThen(sessionClient.waitForTransaction);\n\n    if (postResponse.isErr()) {\n      console.error(\"Error quoting post:\", postResponse.error);\n      setOptimistic(optimistic => ({\n        ...optimistic,\n        repostedOrQuoted: previouslyQuoted,\n      }));\n      throw postResponse.error;\n    }\n\n    return postResponse.value;\n  };\n\n  const tip = async (\n    paymentSource: PaymentSource,\n    amount: string,\n    tokenAddress: string,\n  ): Promise<TxHash | undefined> => {\n    if (!post) {\n      throw new Error(\"Cannot tip without a post\");\n    }\n\n    if (!sessionClient?.isSessionClient() || !walletClient) {\n      throw new Error(\"Must be logged in to tip\");\n    }\n\n    await switchChain();\n\n    setOptimistic(optimistic => ({\n      ...optimistic,\n      tipped: true,\n    }));\n\n    const res = await executePostAction(sessionClient, {\n      post: post.id,\n      action: {\n        tipping: {\n          paymentSource,\n          ...(tokenAddress === NATIVE_TOKEN ? { native: amount } : { value: amount, token: evmAddress(tokenAddress) }),\n        },\n      },\n    })\n      .andThen(handleOperationWith(walletClient))\n      .andThen(sessionClient.waitForTransaction);\n\n    if (res.isErr()) {\n      console.error(\"Error sending tip:\", res.error);\n      setOptimistic(optimistic => ({\n        ...optimistic,\n        tipped: false,\n      }));\n      throw res.error;\n    }\n\n    return res.value;\n  };\n\n  const toggleBookmark = async () => {\n    if (!postId) return;\n\n    setOptimistic(optimistic => ({\n      ...optimistic,\n      bookmarked: !optimistic.bookmarked,\n    }));\n\n    try {\n      if (operations?.hasBookmarked) {\n        await undoBookmarkPost({ post: toPostId(postId) });\n      } else {\n        await bookmarkPost({ post: toPostId(postId) });\n      }\n    } catch (error) {\n      console.error(\"Error bookmarking post:\", error);\n    }\n  };\n\n  return (\n    <LensPostContext.Provider\n      value={{\n        post,\n        toggleLike,\n        comment,\n        collect,\n        repost,\n        quote,\n        tip,\n        toggleBookmark,\n        loading,\n        error,\n        optimistic,\n      }}\n    >\n      {children}\n    </LensPostContext.Provider>\n  );\n};\n",
      "type": "registry:lib"
    },
    {
      "path": "registry/new-york/hooks/use-reaction-toggle.ts",
      "content": "import {\n  AddReactionMutation,\n  AddReactionRequest,\n  invariant,\n  AnyPost,\n  PostReactionType,\n  PublicClient,\n  SessionClient,\n  UndoReactionMutation,\n  UndoReactionRequest,\n} from \"@lens-protocol/react\";\nimport { UseAsyncTask, useAsyncTask } from \"@/registry/new-york/lib/tasks\";\nimport { ResultAsync } from \"@lens-protocol/types\";\n\nexport type ReactionToggleArgs = {\n  session: SessionClient | PublicClient;\n  post: AnyPost;\n};\n\ntype ReactionToggleResult = ResultAsync<void, unknown>;\n\nexport function hasUpvoted(post: AnyPost): boolean {\n  return \"operations\" in post && post.operations?.hasUpvoted === true;\n}\n\nexport const useReactionToggle = (): UseAsyncTask<ReactionToggleArgs, void, unknown> => {\n  return useAsyncTask((args: ReactionToggleArgs): ReactionToggleResult => {\n    invariant(args.session?.isSessionClient(), \"You must be authenticated to use this operation\");\n\n    return ResultAsync.fromPromise(\n      (async () => {\n        const post = args.post;\n        if (hasUpvoted(post)) {\n          const request: UndoReactionRequest = { post: post.id, reaction: PostReactionType.Upvote };\n          args.session?.mutation(UndoReactionMutation, { request });\n        } else {\n          const request: AddReactionRequest = { post: post.id, reaction: PostReactionType.Upvote };\n          args.session?.mutation(AddReactionMutation, { request });\n        }\n      })(),\n      error => {\n        console.error(\"Error toggling reaction:\", error);\n        return error;\n      },\n    );\n  });\n};\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/new-york/lib/lens-utils.ts",
      "content": "import { EvmAddress, MediaAudioType, MediaVideoType } from \"@lens-protocol/react\";\n\nexport const ZeroAddress = \"0x0000000000000000000000000000000000000000\";\nexport const NATIVE_TOKEN = \"0x000000000000000000000000000000000000800A\";\n\n/**\n * Truncate a string to a maximum length, adding an ellipsis in the middle\n * @param address The string to truncate\n * @param maxLength The maximum length of the truncated string, excluding the ellipsis and 0x prefix\n */\nexport const truncateAddress = (address: string, maxLength: number = 8): string => {\n  if (address.length <= maxLength) {\n    return address;\n  }\n  const ellipsis = \"â€¦\";\n  const startLength = Math.ceil((maxLength + ellipsis.length) / 2) + 1;\n  const endLength = Math.floor((maxLength + ellipsis.length) / 2);\n  return address.slice(0, startLength) + ellipsis + address.slice(address.length - endLength);\n};\n\nexport const getCidFromIpfsUrl = (ipfsUrl: string): string => {\n  if (!ipfsUrl.startsWith(\"ipfs://\")) throw new Error(\"IPFS urls must begin with ipfs://\");\n  return ipfsUrl.replace(\"ipfs://\", \"\").replace(/^\\/+|\\/+$/g, \"\");\n};\n\nexport const ipfsUrlToGatewayUrl = (\n  ipfsUrl: string | undefined,\n  gatewayDomain: string = \"https://ipfs.io/ipfs/\",\n): string | undefined => {\n  if (!ipfsUrl || ipfsUrl.length === 0 || !ipfsUrl.startsWith(\"ipfs://\")) return ipfsUrl;\n  const cid = getCidFromIpfsUrl(ipfsUrl);\n  const gatewayUrl = gatewayDomain + cid;\n  const path = ipfsUrl.split(cid)[1];\n  return path ? `${gatewayUrl}${path}` : gatewayUrl;\n};\n\nexport const arweaveUrlToGatewayUrl = (\n  arUrl: string | undefined,\n  gatewayDomain: string = \"https://arweave.net/\",\n): string | undefined => {\n  if (!arUrl || arUrl.length === 0 || !arUrl.startsWith(\"ar://\")) return arUrl;\n  const txId = arUrl.replace(\"ar://\", \"\");\n  return `${gatewayDomain}${txId}`;\n};\n\nexport const lensUrlToGatewayUrl = (\n  lensUrl: string | undefined,\n  gatewayDomain: string = \"https://api.grove.storage/\",\n): string | undefined => {\n  if (!lensUrl || lensUrl.length === 0 || !lensUrl.startsWith(\"lens://\")) return lensUrl;\n  const txId = lensUrl.replace(\"lens://\", \"\");\n  return `${gatewayDomain}${txId}`;\n};\n\n/**\n * Parse a URI and convert it to a gateway URL if it is an IPFS, Arweave, or Lens URL\n * @param uri The URI to parse\n */\nexport const parseUri = (uri: string | null | undefined): string | undefined => {\n  if (!uri) return undefined;\n\n  if (uri.startsWith(\"data:\")) return uri; // Return data URIs as-is\n\n  if (uri.startsWith(\"https://gw.ipfs-lens.dev/ipfs/\")) {\n    const ipfs = uri.replace(\"https://gw.ipfs-lens.dev/ipfs/\", \"ipfs://\");\n    return ipfsUrlToGatewayUrl(ipfs);\n  }\n\n  try {\n    const { protocol } = new URL(uri);\n    switch (protocol) {\n      case \"ipfs:\":\n        return ipfsUrlToGatewayUrl(uri);\n      case \"ar:\":\n        return arweaveUrlToGatewayUrl(uri);\n      case \"lens:\":\n        return lensUrlToGatewayUrl(uri);\n      default:\n        return uri;\n    }\n  } catch {\n    return undefined;\n  }\n};\n\nexport const getAudioExtension = (mediaAudioType: MediaAudioType): string | undefined => {\n  switch (mediaAudioType) {\n    case MediaAudioType.AudioWav:\n      return \"wav\";\n    case MediaAudioType.AudioVndWave:\n      return \"wave\";\n    case MediaAudioType.AudioMpeg:\n      return \"mp3\";\n    case MediaAudioType.AudioOgg:\n      return \"ogg\";\n    case MediaAudioType.AudioMp4:\n      return \"mp4\";\n    case MediaAudioType.AudioAac:\n      return \"aac\";\n    case MediaAudioType.AudioWebm:\n      return \"webm\";\n    case MediaAudioType.AudioFlac:\n      return \"flac\";\n    default:\n      return \"\";\n  }\n};\n\nexport const getVideoExtension = (mediaVideoType: MediaVideoType): string => {\n  switch (mediaVideoType) {\n    case MediaVideoType.VideoMp4:\n      return \"mp4\";\n    case MediaVideoType.VideoMpeg:\n      return \"mpeg\";\n    case MediaVideoType.VideoOgg:\n      return \"ogg\";\n    case MediaVideoType.VideoQuicktime:\n      return \"mov\";\n    case MediaVideoType.VideoWebm:\n      return \"webm\";\n    default:\n      return \"\";\n  }\n};\n\n/**\n * Get the path for a Lens username, optionally including the namespace if it's not the default \"lens\" namespace.\n *\n * Examples:\n * * getUsernamePath(\"@lens/username\") => \"/u/username\"\n * * getUsernamePath(\"@othernamespace/username\", \"0x1234...\") => \"/u/0x1234.../username\"\n *\n * @param username - The full username, including the namespace (e.g., \"@lens/username\")\n * @param namespace - The namespace address of the username. If not provided, the default namespace will be assumed.\n */\nexport const getUsernamePath = (username: string, namespace?: EvmAddress): string => {\n  let path = \"/u/\";\n  if (namespace && !username.startsWith(\"lens\")) path += `${namespace}/`;\n  path += `${username.split(\"/\")[1]}`;\n  return path;\n};\n",
      "type": "registry:lib"
    }
  ]
}
