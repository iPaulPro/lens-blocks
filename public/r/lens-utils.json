{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "lens-utils",
  "type": "registry:lib",
  "title": "Lens Utilities",
  "description": "Utility functions for interacting with Lens Social Protocol, including formatting and data manipulation.",
  "dependencies": [],
  "files": [
    {
      "path": "registry/new-york/lib/lens-utils.ts",
      "content": "import { EvmAddress, MediaAudioType, MediaVideoType } from \"@lens-protocol/react\";\n\nexport const ZeroAddress = \"0x0000000000000000000000000000000000000000\";\nexport const NATIVE_TOKEN = \"0x000000000000000000000000000000000000800A\";\n\n/**\n * Truncate a string to a maximum length, adding an ellipsis in the middle\n * @param address The string to truncate\n * @param maxLength The maximum length of the truncated string, excluding the ellipsis and 0x prefix\n */\nexport const truncateAddress = (address: string, maxLength: number = 8): string => {\n  if (address.length <= maxLength) {\n    return address;\n  }\n  const ellipsis = \"â€¦\";\n  const startLength = Math.ceil((maxLength + ellipsis.length) / 2) + 1;\n  const endLength = Math.floor((maxLength + ellipsis.length) / 2);\n  return address.slice(0, startLength) + ellipsis + address.slice(address.length - endLength);\n};\n\nexport const getCidFromIpfsUrl = (ipfsUrl: string): string => {\n  if (!ipfsUrl.startsWith(\"ipfs://\")) throw new Error(\"IPFS urls must begin with ipfs://\");\n  return ipfsUrl.replace(\"ipfs://\", \"\").replace(/^\\/+|\\/+$/g, \"\");\n};\n\nexport const ipfsUrlToGatewayUrl = (\n  ipfsUrl: string | undefined,\n  gatewayDomain: string = \"https://ipfs.io/ipfs/\",\n): string | undefined => {\n  if (!ipfsUrl || ipfsUrl.length === 0 || !ipfsUrl.startsWith(\"ipfs://\")) return ipfsUrl;\n  const cid = getCidFromIpfsUrl(ipfsUrl);\n  const gatewayUrl = gatewayDomain + cid;\n  const path = ipfsUrl.split(cid)[1];\n  return path ? `${gatewayUrl}${path}` : gatewayUrl;\n};\n\nexport const arweaveUrlToGatewayUrl = (\n  arUrl: string | undefined,\n  gatewayDomain: string = \"https://arweave.net/\",\n): string | undefined => {\n  if (!arUrl || arUrl.length === 0 || !arUrl.startsWith(\"ar://\")) return arUrl;\n  const txId = arUrl.replace(\"ar://\", \"\");\n  return `${gatewayDomain}${txId}`;\n};\n\nexport const lensUrlToGatewayUrl = (\n  lensUrl: string | undefined,\n  gatewayDomain: string = \"https://api.grove.storage/\",\n): string | undefined => {\n  if (!lensUrl || lensUrl.length === 0 || !lensUrl.startsWith(\"lens://\")) return lensUrl;\n  const txId = lensUrl.replace(\"lens://\", \"\");\n  return `${gatewayDomain}${txId}`;\n};\n\n/**\n * Parse a URI and convert it to a gateway URL if it is an IPFS, Arweave, or Lens URL\n * @param uri The URI to parse\n */\nexport const parseUri = (uri: string | null | undefined): string | undefined => {\n  if (!uri) return undefined;\n\n  if (uri.startsWith(\"data:\")) return uri; // Return data URIs as-is\n\n  if (uri.startsWith(\"https://gw.ipfs-lens.dev/ipfs/\")) {\n    const ipfs = uri.replace(\"https://gw.ipfs-lens.dev/ipfs/\", \"ipfs://\");\n    return ipfsUrlToGatewayUrl(ipfs);\n  }\n\n  try {\n    const { protocol } = new URL(uri);\n    switch (protocol) {\n      case \"ipfs:\":\n        return ipfsUrlToGatewayUrl(uri);\n      case \"ar:\":\n        return arweaveUrlToGatewayUrl(uri);\n      case \"lens:\":\n        return lensUrlToGatewayUrl(uri);\n      default:\n        return uri;\n    }\n  } catch {\n    return undefined;\n  }\n};\n\nexport const getAudioExtension = (mediaAudioType: MediaAudioType): string | undefined => {\n  switch (mediaAudioType) {\n    case MediaAudioType.AudioWav:\n      return \"wav\";\n    case MediaAudioType.AudioVndWave:\n      return \"wave\";\n    case MediaAudioType.AudioMpeg:\n      return \"mp3\";\n    case MediaAudioType.AudioOgg:\n      return \"ogg\";\n    case MediaAudioType.AudioMp4:\n      return \"mp4\";\n    case MediaAudioType.AudioAac:\n      return \"aac\";\n    case MediaAudioType.AudioWebm:\n      return \"webm\";\n    case MediaAudioType.AudioFlac:\n      return \"flac\";\n    default:\n      return \"\";\n  }\n};\n\nexport const getVideoExtension = (mediaVideoType: MediaVideoType): string => {\n  switch (mediaVideoType) {\n    case MediaVideoType.VideoMp4:\n      return \"mp4\";\n    case MediaVideoType.VideoMpeg:\n      return \"mpeg\";\n    case MediaVideoType.VideoOgg:\n      return \"ogg\";\n    case MediaVideoType.VideoQuicktime:\n      return \"mov\";\n    case MediaVideoType.VideoWebm:\n      return \"webm\";\n    default:\n      return \"\";\n  }\n};\n\n/**\n * Get the path for a Lens username, optionally including the namespace if it's not the default \"lens\" namespace.\n *\n * Examples:\n * * getUsernamePath(\"@lens/username\") => \"/u/username\"\n * * getUsernamePath(\"@othernamespace/username\", \"0x1234...\") => \"/u/0x1234.../username\"\n *\n * @param username - The full username, including the namespace (e.g., \"@lens/username\")\n * @param namespace - The namespace address of the username. If not provided, the default namespace will be assumed.\n */\nexport const getUsernamePath = (username: string, namespace?: EvmAddress): string => {\n  let path = \"/u/\";\n  if (namespace && !username.startsWith(\"lens\")) path += `${namespace}/`;\n  path += `${username.split(\"/\")[1]}`;\n  return path;\n};\n",
      "type": "registry:lib"
    }
  ]
}
